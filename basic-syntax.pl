#!/usr/bin/perl

use warnings;
no if ($]>=5.018), warnings => 'experimental';
use strict;
no strict 'refs';
use utf8;
use English;
use Encode;

use IPC::Run 'run';

binmode STDIN, "utf8";
binmode STDOUT, "utf8";
binmode STDERR, "utf8";

local $/;
$_ = <>;
$_ = cleanup($_);

my $brackets = 1;

my $fix_sig = 'תי?קו(?:ן|ים)';
my $num_sig = '\d[^ ,.:;"\n\[\]]*+';
my $ext_sig = '(?:(ראשון|שני|שלישי|רביעי|[א-י][\' ]|[טי]"[א-ט]|\d+[א-ת])(\d*)\b)';
my $law_sig = 'ו?ש?[בהלמ]?(?:חוק|פקוד[הת]|תקנות|צו)';

# ignore /^[=:@<]/

s/^[\x{05C1}\x{05C2}]//gm; # Strange typo in reshumot PDF

s/(?:\(תיקון מס'|תיקון \(מס') (\d+)\) (תש.?".)-\d{4}/(תיקון: $2#$1)/g;
s/\n? *([\(\[])(תי?קון|תיקונים):?+ *+(?!מס)/ $1תיקון: /g;
# s/(?<=\(תיקון: )(\S+)\) \(תיקון: (\S+)\)/$1, $2)/g;
s/\) \(תיקון:\s*/, /g;

s/^("?חלק ($num_sig|$ext_sig) *[:,-].*)$/\n= $1 =\n/gm;
s/^("?(פרק|תוספת) ($num_sig|$ext_sig) *[:,-].*)$/\n== $1 ==\n/gm;
s/^("?סימן ($num_sig|$ext_sig) *[:,-].*)$/\n=== $1 ===\n/gm;

s/^(.+)\n(\d+|\*)\n/$2 $1\n/gm;
# s/^(\d+[,;.]?)\n($law_sig.*)/$2 $1/gm;
s/^(\d+[,;.]?.*?)\n(.*?\d{4}( \[.*?\])?)$/$2 $1/gm;

# Should swap chapter title and numeral
s/^(.+)\n("?\(\S{1,4}?\))\n/$2 $1\n/gm;
s/^(.+[^".;\n])\n("?\d\S*?\.)\n/$2 $1\n/gm;
# s/^(\([א-ת]\S{0,3}?\)) *\n/$1 /gm;

# print $_; exit;

s/^(?:\n?@ *|)(\d[^. ]*\.) *(.*)$/"\n@ $1 " . fix_description($2)/gme;
s/^("?\([^)]{1,4}\))/: $1/gm;
s/^(@.*?)\n([^:]+)$/$1\n: $2/gm;

while (s/^(.{5,20}?[^".;\n])\n{2,3}(@ \d.*?\.) /\n\n$2 $1 /gm) {}

s/^(:+) *(\([^)\n]*\)[.;])$/$1 (($2))/gm;
s/^(:+ \([^ )\n]+\)) (\([^)\n]*\)[.;])$/$1 (($2))/gm;


if ($brackets) {
	s/(?<!\[)(ו?ש?[בהלמ]?(סעיף|סעיפים|תקנה|תקנות) $num_sig)(?!\])/[[$1]]/g;
	while (
		s/(?<=\]\] )((?:ו-|או )$num_sig)(?!\])/[[$1]]/g | 
		s/\]\]( עד $num_sig| (?:ו-|או) \(\d\S*?\))/$1]]/g | 
		s/(?<=\]\], )($num_sig)(?!\])/[[$1]]/g
	) {};
	s/(?<!\[)(ו?ש?[בהלמ]?(פרק|פרקים|סימן|סימנים|תוספת) ה?(ז[הו]|ראשון|שני|שלישי|רביעי|[א-י][' ]|[טי]"[א-ט]|\d)[^ ,.:;\n\[\]]{0,8}+)(?!\])/[[$1]]/g;
	s/(?<!\[)(ו?ש?[בהלמ]?(תוספת))\b(?!\])/[[$1]]/g;
	s/(?<!\[)($law_sig [^;.\n]{1,100}?(, |-)\d{4})(?!\])/[[$1]]/g;
	s/\]\] \[\[(?=$law_sig)/ /g;
	s/\[\[($law_sig [^\[\]].*?) ($law_sig[^\[\]].*)\]\]/$1 [[$2]]/g;

	s/\[\[([^\[\]]*+)\[\[(.*?)\]\](.*?)\]\]/[[$1$2$3]]/g;
	s/^(=.*)$/remove_brakets($1)/gme;
}

if (/^\[*(חוק|פקודת|תקנות)\b/s) {
	s/^(?:\<שם\>|) *(.*)\n/"<שם> ". remove_brakets($1) . "\n"/se;
	s/^(.*?\n)/$1\n<מקור>\n...\n/s if (!/<מקור>/);
}

s/\n*(.*?)\n*$/$1\n/s;
s/\n{3,}/\n\n/g;

print $_;

exit;
1;


sub fix_description {
	my $_ = shift;
	s/(?<=\()(תי?קון|תיקונים):? */תיקון: /;
	s/ה(תש.?".?)/$1/g;
	s/(תש.?".) \(מס' (\d.*?)\)/$1-$2/g;
	while (s/(תש.?".)-(\d[^\,]*|),\s*\(מס' (\d.*?)\)/$1-$2, $1-$3/g) {};
	s/\[(תיקון: .*?)\]/($1)/;
	return $_;
}

sub remove_brakets {
	my $_ = shift;
	s/\[\[//;
	s/\]\]//;
	return $_;
}


sub cleanup {
	my $pwd = $0; $pwd =~ s/[^\/]*$//;
	my @cmd = ("$pwd/clear.pl");
	my $in = shift;
	my $out;
	run \@cmd, \$in, \$out, *STDERR;
	return decode_utf8($out);
}
